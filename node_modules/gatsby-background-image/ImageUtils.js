"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.imageReferenceCompleted = exports.imageArrayPropsChanged = exports.imagePropsChanged = exports.getUrlString = exports.getCurrentFromData = exports.switchImageSettings = exports.noscriptImg = exports.activateMultiplePictureRefs = exports.activatePictureRef = exports.createMultiplePictureRefs = exports.createPictureRef = exports.hasPictureElement = exports.resetImageCache = exports.activateCacheForMultipleImages = exports.activateCacheForImage = exports.allInImageCache = exports.inImageCache = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _HelperUtils = require("./HelperUtils");

var DUMMY_IMG = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
var imageCache = Object.create({});
/**
 * Cache if we've seen an image before so we don't both with
 * lazy-loading & fading in on subsequent mounts.
 *
 * @param props
 * @return {*|boolean}
 */

var inImageCache = function inImageCache(props) {
  var convertedProps = (0, _HelperUtils.convertProps)(props);

  if (convertedProps.fluid && Array.isArray(convertedProps.fluid) || convertedProps.fixed && Array.isArray(convertedProps.fixed)) {
    return allInImageCache(props);
  } else {
    // Find src
    var src = convertedProps.fluid ? convertedProps.fluid.src : convertedProps.fixed ? convertedProps.fixed.src : null;
    return imageCache[src] || false;
  }
};
/**
 * Processes an array of cached images for inImageCache.
 *
 * @param props  object    Component Props (with fluid or fixed as array).
 * @return {*|boolean}
 */


exports.inImageCache = inImageCache;

var allInImageCache = function allInImageCache(props) {
  var convertedProps = (0, _HelperUtils.convertProps)(props); // Extract Image Array.

  var imageStack = convertedProps.fluid || convertedProps.fixed; // Only return true if every image is in cache.

  return imageStack.every(function (imageData) {
    if (convertedProps.fluid) {
      return inImageCache({
        fluid: imageData
      });
    } else {
      return inImageCache({
        fixed: imageData
      });
    }
  });
};
/**
 * Adds an Image to imageCache.
 *
 * @param props
 */


exports.allInImageCache = allInImageCache;

var activateCacheForImage = function activateCacheForImage(props) {
  var convertedProps = (0, _HelperUtils.convertProps)(props);

  if (convertedProps.fluid && Array.isArray(convertedProps.fluid) || convertedProps.fixed && Array.isArray(convertedProps.fixed)) {
    return activateCacheForMultipleImages(props);
  } else {
    // Find src
    var src = convertedProps.fluid ? convertedProps.fluid.src : convertedProps.fixed ? convertedProps.fixed.src : null;

    if (src) {
      imageCache[src] = true;
    }
  }
};
/**
 * Activates the Cache for multiple Images.
 *
 * @param props
 */


exports.activateCacheForImage = activateCacheForImage;

var activateCacheForMultipleImages = function activateCacheForMultipleImages(props) {
  var convertedProps = (0, _HelperUtils.convertProps)(props); // Extract Image Array.

  var imageStack = convertedProps.fluid || convertedProps.fixed;
  imageStack.forEach(function (imageData) {
    if (convertedProps.fluid) {
      activateCacheForImage({
        fluid: imageData
      });
    } else {
      activateCacheForImage({
        fixed: imageData
      });
    }
  });
};
/**
 * Resets the image cache (especially important for reliable tests).
 */


exports.activateCacheForMultipleImages = activateCacheForMultipleImages;

var resetImageCache = function resetImageCache() {
  for (var prop in imageCache) {
    delete imageCache[prop];
  }
};
/**
 * Returns the availability of the HTMLPictureElement unless in SSR mode.
 *
 * @return {boolean}
 */


exports.resetImageCache = resetImageCache;

var hasPictureElement = function hasPictureElement() {
  return typeof HTMLPictureElement !== "undefined" || typeof window === "undefined";
};
/**
 * Creates an image reference to be activated on critical or visibility.
 * @param props
 * @param onLoad
 * @return {HTMLImageElement|null|Array}
 */


exports.hasPictureElement = hasPictureElement;

var createPictureRef = function createPictureRef(props, onLoad) {
  var convertedProps = (0, _HelperUtils.convertProps)(props);

  if (typeof window !== "undefined" && (typeof convertedProps.fluid !== "undefined" || typeof convertedProps.fixed !== "undefined")) {
    if (convertedProps.fluid && Array.isArray(convertedProps.fluid) || convertedProps.fixed && Array.isArray(convertedProps.fixed)) {
      return createMultiplePictureRefs(props, onLoad);
    } else {
      var img = new Image();

      img.onload = function () {
        return onLoad();
      };

      if (!img.complete && typeof convertedProps.onLoad === "function") {
        img.addEventListener('load', convertedProps.onLoad);
      }

      if (typeof convertedProps.onError === "function") {
        img.addEventListener('error', convertedProps.onError);
      }

      if (convertedProps.crossOrigin) {
        img.crossOrigin = convertedProps.crossOrigin;
      } // Only directly activate the image if critical (preload).


      if (convertedProps.critical || convertedProps.isVisible) {
        return activatePictureRef(img, convertedProps);
      }

      return img;
    }
  }

  return null;
};
/**
 * Creates multiple image references. Internal function.
 *
 * @param props   object    Component Props (with fluid or fixed as array).
 * @param onLoad  function  Callback for load handling.
 */


exports.createPictureRef = createPictureRef;

var createMultiplePictureRefs = function createMultiplePictureRefs(props, onLoad) {
  var convertedProps = (0, _HelperUtils.convertProps)(props); // Extract Image Array.

  var imageStack = convertedProps.fluid || convertedProps.fixed;
  return imageStack.map(function (imageData) {
    if (convertedProps.fluid) {
      return createPictureRef((0, _extends2["default"])({}, convertedProps, {
        fluid: imageData
      }), onLoad);
    } else {
      return createPictureRef((0, _extends2["default"])({}, convertedProps, {
        fixed: imageData
      }), onLoad);
    }
  });
};
/**
 * Creates a picture element for the browser to decide which image to load.
 *
 * @param imageRef
 * @param props
 * @return {null|Array|*}
 */


exports.createMultiplePictureRefs = createMultiplePictureRefs;

var activatePictureRef = function activatePictureRef(imageRef, props) {
  var convertedProps = (0, _HelperUtils.convertProps)(props);

  if (typeof window !== "undefined" && (typeof convertedProps.fluid !== "undefined" || typeof convertedProps.fixed !== "undefined")) {
    if (convertedProps.fluid && Array.isArray(convertedProps.fluid) || convertedProps.fixed && Array.isArray(convertedProps.fixed)) {
      return activateMultiplePictureRefs(imageRef, props);
    } else {
      var imageData = convertedProps.fluid ? convertedProps.fluid : convertedProps.fixed; // Prevent adding HTMLPictureElement if it isn't supported (e.g. IE11),
      // but don't prevent it during SSR.

      if (hasPictureElement()) {
        var pic = document.createElement('picture');

        if (imageData.srcSetWebp) {
          var sourcesWebP = document.createElement('source');
          sourcesWebP.type = "image/webp";
          sourcesWebP.srcset = imageData.srcSetWebp;
          sourcesWebP.sizes = imageData.sizes;
          pic.appendChild(sourcesWebP);
        }

        pic.appendChild(imageRef);
      }

      imageRef.srcset = imageData.srcSet ? imageData.srcSet : "";
      imageRef.src = imageData.src ? imageData.src : "";
      return imageRef;
    }
  }

  return null;
};
/**
 * Creates multiple picture elements.
 *
 * @param imageRefs
 * @param props
 * @return {Array||null}
 */


exports.activatePictureRef = activatePictureRef;

var activateMultiplePictureRefs = function activateMultiplePictureRefs(imageRefs, props) {
  var convertedProps = (0, _HelperUtils.convertProps)(props); // Extract Image Array.

  return imageRefs.map(function (imageRef, index) {
    if (convertedProps.fluid) {
      return activatePictureRef(imageRef, (0, _extends2["default"])({}, convertedProps, {
        fluid: convertedProps.fluid[index]
      }));
    } else {
      return activatePictureRef(imageRef, (0, _extends2["default"])({}, convertedProps, {
        fixed: convertedProps.fixed[index]
      }));
    }
  });
};
/**
 * Create basic image for a noscript event.
 *
 * @param props
 * @return {string}
 */


exports.activateMultiplePictureRefs = activateMultiplePictureRefs;

var noscriptImg = function noscriptImg(props) {
  // Check if prop exists before adding each attribute to the string output below to prevent
  // HTML validation issues caused by empty values like width="" and height=""
  var src = props.src ? "src=\"" + props.src + "\" " : "src=\"\" "; // required attribute

  var sizes = props.sizes ? "sizes=\"" + props.sizes + "\" " : "";
  var srcSetWebp = props.srcSetWebp ? "<source type='image/webp' srcset=\"" + props.srcSetWebp + "\" " + sizes + "/>" : "";
  var srcSet = props.srcSet ? "srcset=\"" + props.srcSet + "\" " : "";
  var title = props.title ? "title=\"" + props.title + "\" " : "";
  var alt = props.alt ? "alt=\"" + props.alt + "\" " : "alt=\"\" "; // required attribute

  var width = props.width ? "width=\"" + props.width + "\" " : "";
  var height = props.height ? "height=\"" + props.height + "\" " : "";
  var opacity = props.opacity ? props.opacity : "1";
  var transitionDelay = props.transitionDelay ? props.transitionDelay : "0.5s";
  var crossOrigin = props.crossOrigin ? "crossorigin=\"" + props.crossOrigin + "\" " : ""; // Prevent adding HTMLPictureElement if it isn't supported (e.g. IE11),
  // but don't prevent it during SSR.

  var innerImage = "<img " + width + height + sizes + srcSet + src + alt + title + crossOrigin + "style=\"position:absolute;top:0;left:0;z-index:-1;transition:opacity 0.5s;transition-delay:" + transitionDelay + ";opacity:" + opacity + ";width:100%;height:100%;object-fit:cover;object-position:center\"/>";
  return hasPictureElement() ? "<picture>" + srcSetWebp + innerImage + "</picture>" : innerImage;
};
/**
 * Compares the old states to the new and changes image settings accordingly.
 *
 * @param image     string||array   Base data for one or multiple Images.
 * @param bgImage   string          Last background-image string.
 * @param imageRef  string||array   References to one or multiple Images.
 * @param state     object          Component state.
 * @return {{afterOpacity: number, bgColor: *, bgImage: *, nextImage: string}}
 */


exports.noscriptImg = noscriptImg;

var switchImageSettings = function switchImageSettings(_ref) {
  var image = _ref.image,
      bgImage = _ref.bgImage,
      imageRef = _ref.imageRef,
      state = _ref.state;
  // Read currentSrc from imageRef (if exists).
  var currentSources = getCurrentFromData({
    data: imageRef,
    propName: "currentSrc"
  }); // Backup bgImage to lastImage.

  var lastImage = bgImage;
  var returnArray = Array.isArray(image); // Set the backgroundImage according to images available.

  var nextImage;

  if (returnArray) {
    // Check for tracedSVG first.
    nextImage = getCurrentFromData({
      data: image,
      propName: "tracedSVG",
      returnArray: returnArray
    }); // Now combine with base64 images.

    nextImage = (0, _HelperUtils.combineArray)(getCurrentFromData({
      data: image,
      propName: "base64",
      returnArray: returnArray
    }), nextImage); // Do we have at least one img loaded?

    if (state.imgLoaded && state.isVisible) {
      if (currentSources) {
        nextImage = (0, _HelperUtils.combineArray)(getCurrentFromData({
          data: imageRef,
          propName: "currentSrc",
          returnArray: returnArray
        }), nextImage);
      } else {
        // Should we still have no nextImage it might be because currentSrc is missing.
        nextImage = (0, _HelperUtils.combineArray)(getCurrentFromData({
          data: imageRef,
          propName: "src",
          returnArray: returnArray
        }), nextImage);
      }
    } // Fill the rest of the background-images with a transparent dummy pixel,
    // lest the other background-* properties can't target the correct image.


    var dummyImageURI = getUrlString({
      imageString: DUMMY_IMG
    });
    var dummyArray = Array(image.length).fill(dummyImageURI); // Now combine the two arrays and join them.

    nextImage = (0, _HelperUtils.filteredJoin)((0, _HelperUtils.combineArray)(nextImage, dummyArray));
  } else {
    nextImage = "";
    if (image.tracedSVG) nextImage = getCurrentFromData({
      data: image,
      propName: "tracedSVG"
    });
    if (image.base64 && !image.tracedSVG) nextImage = getCurrentFromData({
      data: image,
      propName: "base64"
    });

    if (state.imgLoaded && state.isVisible) {
      nextImage = currentSources || getCurrentFromData({
        data: imageRef,
        propName: "src"
      });
    }
  } // Fall back on lastImage (important for prop changes) if all else fails.


  if (!nextImage) nextImage = lastImage; // Change opacity according to imageState.

  var afterOpacity = state.imageState % 2;
  return {
    lastImage: lastImage,
    nextImage: nextImage,
    afterOpacity: afterOpacity
  };
};
/**
 * Extracts a value from an imageRef or image object or an array of them.
 *
 * @param data
 * @param propName
 * @param addUrl
 * @param returnArray
 * @return {string||array}
 */


exports.switchImageSettings = switchImageSettings;

var getCurrentFromData = function getCurrentFromData(_ref2) {
  var data = _ref2.data,
      propName = _ref2.propName,
      _ref2$addUrl = _ref2.addUrl,
      addUrl = _ref2$addUrl === void 0 ? true : _ref2$addUrl,
      _ref2$returnArray = _ref2.returnArray,
      returnArray = _ref2$returnArray === void 0 ? false : _ref2$returnArray;
  if (!data || !propName) return ""; // Handle tracedSVG with "special care".

  var tracedSVG = propName === "tracedSVG";

  if (Array.isArray(data)) {
    // Filter out all elements not having the propName and return remaining.
    var imageString = data // .filter(dataElement => {
    //   return propName in dataElement && dataElement[propName]
    // })
    .map(function (dataElement) {
      return dataElement[propName] || "";
    }); // Encapsulate in URL string and return.

    return getUrlString({
      imageString: imageString,
      tracedSVG: tracedSVG,
      addUrl: addUrl,
      returnArray: returnArray
    });
  } else {
    return propName in data ? getUrlString({
      imageString: data[propName],
      tracedSVG: tracedSVG,
      addUrl: addUrl
    }) : "";
  }
};
/**
 * Encapsulates an imageString with a url if needed.
 *
 * @param imageString   string    String to encapsulate.
 * @param tracedSVG     boolean   Special care for SVGs.
 * @param addUrl        boolean   If the string should be encapsulated or not.
 * @param returnArray   boolean   Return concatenated string or Array.
 * @return {string||array}
 */


exports.getCurrentFromData = getCurrentFromData;

var getUrlString = function getUrlString(_ref3) {
  var imageString = _ref3.imageString,
      _ref3$tracedSVG = _ref3.tracedSVG,
      tracedSVG = _ref3$tracedSVG === void 0 ? false : _ref3$tracedSVG,
      _ref3$addUrl = _ref3.addUrl,
      addUrl = _ref3$addUrl === void 0 ? true : _ref3$addUrl,
      _ref3$returnArray = _ref3.returnArray,
      returnArray = _ref3$returnArray === void 0 ? false : _ref3$returnArray;

  if (Array.isArray(imageString)) {
    var stringArray = imageString.map(function (currentString) {
      var currentReturnString = tracedSVG && currentString ? "\"" + currentString + "\"" : currentString;
      return addUrl && currentString ? "url(" + currentReturnString + ")" : currentReturnString;
    });
    return returnArray ? stringArray : (0, _HelperUtils.filteredJoin)(stringArray);
  } else {
    var returnString = tracedSVG && imageString ? "\"" + imageString + "\"" : imageString;
    return imageString ? addUrl ? "url(" + returnString + ")" : returnString : "";
  }
};
/**
 * Checks if any image props have changed.
 *
 * @param props
 * @param prevProps
 * @return {*}
 */


exports.getUrlString = getUrlString;

var imagePropsChanged = function imagePropsChanged(props, prevProps) {
  return (// Do we have different image types?
    props.fluid && !prevProps.fluid || props.fixed && !prevProps.fixed || imageArrayPropsChanged(props, prevProps) || // Are single image sources different?
    props.fluid && prevProps.fluid && props.fluid.src !== prevProps.fluid.src || props.fixed && prevProps.fixed && props.fixed.src !== prevProps.fixed.src
  );
};
/**
 * Decides if two given props with array images differ.
 *
 * @param props
 * @param prevProps
 * @return {boolean}
 */


exports.imagePropsChanged = imagePropsChanged;

var imageArrayPropsChanged = function imageArrayPropsChanged(props, prevProps) {
  var isPropsFluidArray = Array.isArray(props.fluid);
  var isPrevPropsFluidArray = Array.isArray(prevProps.fluid);
  var isPropsFixedArray = Array.isArray(props.fixed);
  var isPrevPropsFixedArray = Array.isArray(prevProps.fixed);

  if ( // Did the props change to a single image?
  isPropsFluidArray && !isPrevPropsFluidArray || isPropsFixedArray && !isPrevPropsFixedArray || // Did the props change to an Array?
  !isPropsFluidArray && isPrevPropsFluidArray || !isPropsFixedArray && isPrevPropsFixedArray) {
    return true;
  } else {
    // Are the lengths or sources in the Arrays different?
    if (isPropsFluidArray && isPrevPropsFluidArray) {
      if (props.fluid.length === prevProps.fluid.length) {
        return props.fluid.every(function (image, index) {
          return image.src !== prevProps.fluid[index].src;
        });
      }

      return true;
    } else if (isPropsFixedArray && isPrevPropsFixedArray) {
      if (props.fixed.length === prevProps.fixed.length) {
        return props.fixed.every(function (image, index) {
          return image.src !== prevProps.fixed[index].src;
        });
      }

      return true;
    }
  }
};
/**
 * Checks if an image (array) reference is existing and tests for complete.
 *
 * @param imageRef    HTMLImageElement||array   Image reference(s).
 * @return {boolean}
 */


exports.imageArrayPropsChanged = imageArrayPropsChanged;

var imageReferenceCompleted = function imageReferenceCompleted(imageRef) {
  return imageRef ? Array.isArray(imageRef) ? imageRef.every(function (singleImageRef) {
    return singleImageRef.complete;
  }) : imageRef.complete : false;
};

exports.imageReferenceCompleted = imageReferenceCompleted;